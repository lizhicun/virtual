# virtual

## 虚函数表
[请找出下面哪句话不对]
对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其内容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

举个栗子
```

class Base {
     public:
            virtual void f() { cout << "Base::f" << endl; }
            virtual void g() { cout << "Base::g" << endl; }
            virtual void h() { cout << "Base::h" << endl; }
};

int main() {

    typedef void(*Fun)(void);
    Base b;
    Fun pFun = NULL;
    cout << "虚函数表地址：" << (int*)*(int*)(&b) << endl;
    cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)*(int*)(&b) << endl;
    // Invoke(调用) the first virtual function
    pFun = (Fun)*((int*)*(int*)(&b));
    pFun();
}

```
插播一则函数指针，直接看例子
```
# include <stdio.h>
int Max(int, int);  //函数声明
int main(void)
{
    int(*p)(int, int);  //定义一个函数指针
    int a, b, c;
    p = Max;  //把函数Max赋给指针变量p, 使p指向Max函数
    printf("please enter a and b:");
    scanf("%d%d", &a, &b);
    c = (*p)(a, b);  //通过函数指针调用Max函数
    printf("a = %d\nb = %d\nmax = %d\n", a, b, c);
    return 0;
}
int Max(int x, int y)  //定义Max函数
{
    int z;
    if (x > y)
    {
        z = x;
    }
    else
    {
        z = y;
    }
    return z;
}
```

回到第一个例子，对(int*)*(int*)*(int*)(&b)进行分析一下：对&b强转为int*得到了b的内存首地址，然后(int*)*是对此地址取值再强转得到虚函数表的首地址，后面再一次取值强转就得到了一个虚函数的地址指针
[图1]

### 一般继承（无虚函数覆盖）
[继承关系的图]

对于实例：Derive d; 它所指向的虚函数表如下
[图]

可以看到：
* 虚函数按照其声明顺序放于表中
* 父类的虚函数在子类的虚函数前面

举个栗子

### 一般继承（有虚函数覆盖）
[图]

可以看到:
* 覆盖的f()函数被放到了虚表中原来父类虚函数的位置
* 没有被覆盖的函数依旧

这样，我们就可以看到对于下面这样的程序.由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了
```
Base *b = new Derive();
b->f(); 
```

### 多继承（无虚函数覆盖）
[图]
子类的虚函数表，是下面这个样子
[图]
可以看到：
* 每个父类都有自己的虚表
* 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

### 多继承（有虚函数覆盖）
[图]
子类的虚函数表，是下面这个样子
[图]
我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针.
举个栗子
